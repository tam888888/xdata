<!DOCTYPE html>
<html>

<head>
    <title>Sector Chart</title>
    <script src="https://code.jquery.com/jquery-3.7.0.js"></script>
    <script src="https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.2/js/dataTables.buttons.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/pdfmake.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/vfs_fonts.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.2/js/buttons.html5.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.2/js/buttons.print.min.js"></script>
    <!-- <script src="https://cdn.datatables.net/scroller/2.3.0/js/dataTables.scroller.min.js"></script> -->
    <script src="https://cdn.datatables.net/keytable/2.11.0/js/dataTables.keyTable.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.2/js/buttons.colVis.min.js"></script>
    <script src="https://cdn.datatables.net/fixedcolumns/4.3.0/js/dataTables.fixedColumns.min.js"></script>
    <script src="https://cdn.datatables.net/fixedheader/3.4.0/js/dataTables.fixedHeader.min.js"></script>



    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/fixedheader/3.4.0/css/fixedHeader.dataTables.min.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/fixedcolumns/4.3.0/css/fixedColumns.dataTables.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.13.7/css/jquery.dataTables.min.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/scroller/2.3.0/css/scroller.dataTables.min.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/keytable/2.11.0/css/keyTable.dataTables.min.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/buttons/2.4.2/css/buttons.dataTables.min.css">


    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"
        integrity="sha384-c79GN5VsunZvi+Q/WObgk2in0CbZsHnjEqvFxC5DxHn9lTfNce2WW6h2pH6u/kF+"
        crossorigin="anonymous"></script>

    <!-- <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script> -->
    <script src="https://github.com/tam888888/stockData/releases/download/1.0.0/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://github.com/tam888888/stockData/releases/download/1.0.0/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeral.js/2.0.6/numeral.min.js"></script>

    <link rel="stylesheet" type="text/css" href="tooltipster.bundle.min.css">
    <script type="text/javascript" charset="utf8" src="https://github.com/tam888888/stockData/releases/download/1.0.0/tooltipster.bundle.min.js"></script>

    <style>
        div.dataTables_wrapper div.dataTables_info {
            padding-top: 0px;
        }

        div.dataTables_wrapper div.dataTables_info {
            font-size: 6px;
            /* Set font size for information text (e.g., "Showing 1 to 10 of 100 entries") */
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        table,
        th,
        td {
            border: 1px solid #ccc;
        }

        th,
        td {
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }
    </style>
    <style>
        /* CSS for limiting the number of rows and adding a vertical scroll */
        #timelineContainer {
            max-height: 600px;
            /* Set the maximum height for the table */
            overflow-y: auto;
            /* Enable vertical scrolling */
        }
    </style>
    <style>
        /* CSS for enabling both horizontal and vertical scrolling for the entire page */
        body,
        html {
            overflow: scroll;
            /* Enable both horizontal and vertical scrolling for the entire page */
        }
    </style>
    <style>
        /* #chartcontainer {
            text-align: center;
        }

        #vnindex,#busd {
            display: inline;
        } */
        #chartcontainer {
            display: flex;
            justify-content: center;
        }

        #combineDiv {
            display: flex;
            /* flex-wrap: wrap; */
            /* Cho phép các ô chuyển hàng khi không đủ không gian */
            /* justify-content: center; */
        }

        .hidden-element {
            display: none;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 700px);
            /* 3 cột trong mỗi hàng */
            grid-gap: 10px;
            /* Khoảng cách giữa các ô */
            /* grid-auto-rows: 300px; */
        }

        .grid-item {
            /* Định dạng cho mỗi ô trong grid */
            border: 1px solid #ddd;
            padding: 10px;
            width: 700px;
            /* Chiều rộng của mỗi ô */
            height: 700px;
            /* Chiều cao của mỗi ô */
        }

        .flex-container {
            display: flex;
            flex-wrap: wrap;
            /* Cho phép các ô chuyển hàng khi không đủ không gian */
            justify-content: center;
        }

        .flex-item3 {
            flex: 0 0 calc(33.33% - 20px);
            /* 33.33% chiều rộng mỗi ô, trừ đi khoảng cách giữa các ô */
            box-sizing: border-box;
            /* Đảm bảo padding và border không làm tăng kích thước thực tế của ô */
            margin: 10px;
            /* Khoảng cách giữa các ô */
        }

        .flex-item2 {
            flex: 0 0 calc(50% - 20px);
            /* 33.33% chiều rộng mỗi ô, trừ đi khoảng cách giữa các ô */
            box-sizing: border-box;
            /* Đảm bảo padding và border không làm tăng kích thước thực tế của ô */
            margin: 10px;
            /* Khoảng cách giữa các ô */
        }

        .flex-item1 {
            flex: 0 0 calc(80% - 20px);
            /* 33.33% chiều rộng mỗi ô, trừ đi khoảng cách giữa các ô */
            box-sizing: border-box;
            /* Đảm bảo padding và border không làm tăng kích thước thực tế của ô */
            margin: 10px;
            /* Khoảng cách giữa các ô */
        }

        .flex-itemOne {
            flex: 0 0 calc(80% - 20px);
            /* 33.33% chiều rộng mỗi ô, trừ đi khoảng cách giữa các ô */
            box-sizing: border-box;
            /* Đảm bảo padding và border không làm tăng kích thước thực tế của ô */
            margin: 10px;
            /* Khoảng cách giữa các ô */
        }

        .custom-link {
            text-decoration: none !important;
        }

        /* .tooltip {
            position: absolute;
            z-index: 1;
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            padding: 5px;
            border-radius: 5px;
            display: none;
        } */

        .tooltipContainer {
            overflow: hidden;
            position: relative;
            display: inline-block;
            border: 2px solid #007bff;
            /* Đường viền màu xanh */
            border-radius: 10px;
            /* Bo tròn */
            padding: 0px;
            background-color: FloralWhite;
        }

        .tooltipHeader {
            position: relative;
            display: inline-block;
            border: 2px solid #007bff;
            /* Đường viền màu xanh */
            border-radius: 10px;
            /* Bo tròn */
            padding: 10px;
        }

        .custom-theme {
            background-color: #8a2be2;
            /* Purple background color */
            color: #fff;
            /* White text color */
            border-radius: 5px;
            /* Rounded corners */
        }

        .my-custom-theme {
            border-radius: none;
            border: none;
            background: rgba(0, 0, 0, 0);
            color: #000;
            border-color: rgba(0, 0, 0, 0);
        }

        /* Use this next selector to style things like font-size and line-height: */
        .my-custom-theme .tooltipster-content {
            font-family: Arial, sans-serif;
            font-size: 14px;
            line-height: 16px;
            padding: 8px 10px;
            background: lightyellow;
            color: #111010;
            border-radius: none;
            border: none;
        }

        .scrollable-div {
            width: 100%;
            /* Set the width as needed */
            height: 700px;
            /* Set the height as needed */
            overflow: auto;
            /* Enable scrolling */
            border: 1px solid #ccc;
            /* Optional: Add a border for better visibility */
        }
    </style>
</head>

<body>
    <br />
    <br />
    <br />
    <div id="combineDiv" class="flex-container">
    </div>
    <!-- <div class="tooltip" id="tooltipContainer"></div> -->
    <div class="scrollable-div">
        <table id="myTable" class="display">
            <thead>
                <tr>
                    <th>Sector</th>
                    <th>Thời gian</th>
                    <th>Toàn ngành<br />(%)</th>
                    <th>Mã lớn<br />(%)</th>
                    <th>Mã Trần</th>
                    <th>Mã Tăng</th>
                    <th>Mã Đứng Giá</th>
                    <th>Mã Giảm</th>
                    <th>Mã Sàn</th>
                </tr>
            </thead>
            <tfoot id="footTable">
                <tr>
                    <th>Thống kê</th>
                    <th></th>
                    <th></th>
                    <th></th>
                    <th></th>
                    <th></th>
                    <th></th>
                    <th></th>
                    <th></th>
                </tr>
            </tfoot>
            <tbody>
                <!-- Dữ liệu sẽ được thêm ở đây -->
            </tbody>

        </table>
    </div>



    <script>
        // Chart.register(ChartDataLabels);
        let vf = (v) => {
            if (v) return v;
            return 0
        }
        const url = new URL(window.location.href);
        const queryParams = url.searchParams;
        var interval = queryParams.get('interval');
        if (!interval) interval = 5
        var sortby = queryParams.get('sortby');
        if (!sortby) {
            sortby = 'pct'
        }
        var valMin = queryParams.get('valMin');
        if (!valMin) {
            valMin = 10000000000;
        } else {
            valMin = +valMin
        }

        statsHead = document.getElementById('footTable');
        statsHead.innerHTML = ''
        var theadRow = document.createElement('tr');
        statsHead.appendChild(theadRow);

        var percent = queryParams.get('percent');
        let combineDivContainer = document.getElementById('combineDiv')
        var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        let flex = "flex-item2"
        if (width < 1024) {
            flex = "flex-item1"
        } else if (width > 1024 && width <= 1920) {
            flex = "flex-item2"
        } else {
            flex = "flex-item3"
        }
        flex = "flex-item1"
        if (combineDivContainer) {
            let innerHTML = '';
            innerHTML += '<div class="' + flex + '"><canvas id="' + 'stackedsectors' + 'Chart" style="width: 100%; margin: 0 auto;"></canvas></div>'
            innerHTML += '<div class="' + flex + '"><canvas id="' + 'stackedsectorsVal' + 'Chart" style="width: 100%; margin: 0 auto;"></canvas></div>'
            combineDivContainer.innerHTML = innerHTML;
        }



        const zoomOptions = {
            // pan: {
            //     enabled: true,
            //     mode: 'xy',
            //     modifierKey: 'ctrl',
            // },
            pan: {
                enabled: true,
                onPanStart({ chart, point }) {
                    const area = chart.chartArea;
                    const w25 = area.width * 0.25;
                    const h25 = area.height * 0.25;
                    if (point.x < area.left + w25 || point.x > area.right - w25
                        || point.y < area.top + h25 || point.y > area.bottom - h25) {
                        return false; // abort
                    }
                },
                mode: 'xy',
                modifierKey: 'ctrl',
            },
            zoom: {
                mode: 'xy',
                drag: {
                    enabled: true,
                    borderColor: 'rgb(54, 162, 235)',
                    borderWidth: 1,
                    backgroundColor: 'rgba(54, 162, 235, 0.3)'
                }
            }
        };
        let labelValue;
        let labelValue2;
        function createChart(symbol, plugins) {
            //combineChart
            const ctxCombineChart = document.getElementById(symbol + 'Chart').getContext('2d');
            var lineTension = 0.2
            const combineData = {
                labels: ['A', 'B', 'C'],
                datasets: [
                    {
                        label: 'Mã trần',
                        lineTension: lineTension,
                        xAxisID: 'xlabels',
                        yAxisID: 'y-axis-vnindex',
                        data: [1, 2],//Array(2).fill().map(() => Math.floor(Math.random() * 100)),
                        borderColor: 'Magenta',
                        backgroundColor: 'Magenta',
                        pointRadius: 2, // Kích thước đánh dấu
                        pointHoverRadius: 6, // Kích thước đánh dấu khi di chuột qua   
                        borderWidth: 2, // Kích thước của đường                        
                        stack: 'Stack 0',

                    },
                    {
                        label: 'Mã tăng',
                        lineTension: lineTension,
                        yAxisID: 'y-axis-vnindex',
                        borderColor: 'green',
                        backgroundColor: 'green', // Red
                        data: [3, 4],
                        fill: false,
                        // hidden: true, // Ẩn đường này mặc định
                        pointRadius: 2, // Kích thước đánh dấu
                        pointHoverRadius: 6, // Kích thước đánh dấu khi di chuột qua   
                        borderWidth: 2, // Kích thước của đường  
                        stack: 'Stack 0',
                    },
                    {
                        label: 'Mã đứng giá',
                        lineTension: lineTension,
                        yAxisID: 'y-axis-vnindex',
                        borderColor: 'gold',
                        backgroundColor: 'gold', // Blue
                        data: [5, 6],
                        fill: false,
                        pointRadius: 2, // Kích thước đánh dấu
                        pointHoverRadius: 6, // Kích thước đánh dấu khi di chuột qua   
                        borderWidth: 2, // Kích thước của đường                        
                        stack: 'Stack 0',
                    },
                    {
                        label: 'Mã giảm',
                        lineTension: lineTension,
                        yAxisID: 'y-axis-vnindex',
                        borderColor: 'red',
                        backgroundColor: 'red', // Blue
                        data: [7, 8],
                        fill: false,
                        pointRadius: 2, // Kích thước đánh dấu
                        pointHoverRadius: 6, // Kích thước đánh dấu khi di chuột qua   
                        borderWidth: 2, // Kích thước của đường                    
                        stack: 'Stack 0',
                    },
                    {
                        label: 'Mã sàn',
                        lineTension: lineTension,
                        yAxisID: 'y-axis-vnindex',
                        borderColor: 'cyan',
                        backgroundColor: 'cyan', // Blue
                        data: [9, 10],
                        fill: false,
                        pointRadius: 2, // Kích thước đánh dấu
                        pointHoverRadius: 6, // Kích thước đánh dấu khi di chuột qua   
                        borderWidth: 2, // Kích thước của đường                        
                        stack: 'Stack 0',
                    }
                ],
            };
            const combineConfig = {
                type: 'bar', // Đây là loại biểu đồ đường (line chart)
                data: combineData,
                plugins: plugins,
                options: {
                    indexAxis: 'y',
                    legend: {
                        position: 'right',
                    },
                    scales: {
                        // x: {
                        //     position: 'right',
                        //     stacked: true,
                        // },
                        // y: {
                        //     stacked: true
                        // },
                        'xlabels': {
                            // stacked: true,
                            position: 'top',
                            title: {
                                display: true,
                                text: symbol,
                                font: {
                                    size: 24,          // Kích thước phông chữ
                                    weight: 'bold',  // In đậm                                
                                }
                            },
                            ticks: {
                                callback: function (value, index, values) {
                                    if (symbol === 'stackedsectorsVal')
                                        return numeral(value / 1000000000).format('0,0.00')
                                    else return value
                                }
                            }
                        },
                        'y-axis-vnindex': {
                            // stacked: true,
                            // position: 'right',
                            title: {
                                display: true,
                                text: symbol,
                                font: {
                                    size: 24,          // Kích thước phông chữ
                                    weight: 'bold',  // In đậm                                
                                }
                            },
                        },

                    },
                    plugins: {
                        zoom: zoomOptions,
                        datalabels: {
                            align: symbol === 'stackedsectorsVal' ? 'end' : 'center',
                            anchor: symbol === 'stackedsectorsVal' ? 'end' : 'center',
                            // offset: 4,
                            color: symbol === 'stackedsectorsVal' ? 'blue' : 'white',
                            font: {
                                size: 8 // Set the font size for the text labels
                            },
                            formatter: function (value, context) {
                                if (symbol === 'stackedsectorsVal') {
                                    if (context.dataset.label === 'Mã sàn') {
                                        if (labelValue) {
                                            return labelValue2[context.dataIndex] + '(%) ' + numeral(labelValue[context.dataIndex]).format('0,0');
                                        }
                                        else
                                            return value
                                    }
                                    else {
                                        return ''
                                    }
                                }
                                if (!percent) return value;
                                if (value === 0) { return '' }
                                if (value < 5) { return value }
                                return value + "%"; // Display the value as the text label
                            }
                        }
                    },
                },

            };
            var combineChart = new Chart(ctxCombineChart, combineConfig);
            return combineChart;
        }


        var combineChart = createChart('stackedsectors', [ChartDataLabels]);
        var combineChartVal = createChart('stackedsectorsVal', [ChartDataLabels]);


        let fields = ["sector", "time", "all", "allBig"
            , "tran", "tang", "thamchieu", "giam", "san",
        ]

        $.fn.dataTable.ext.errMode = 'none';

        $('#myTable').DataTable(
            {
                fixedHeader: {
                    // header: true,
                    // footer: true
                },
                fixedColumns: {
                    left: 1,
                    right: 1
                },
                columnDefs: [

                    { targets: [1, 2, 3], "width": "2%" },
                    {
                        targets: [2, 3],
                        render: function (data, type, row, meta) {
                            var dataout = ''
                            if (type === 'display') {
                                var color = 'blue'
                                // console.log(row)
                                var symbols = []
                                if (meta.col == 3) {
                                    symbols = row['allBigO']
                                } else {
                                    symbols = row['allO']
                                }
                                var x = Object.values(symbols).sort((a, b) => { return b.pct - a.pct })
                                dataout += '<span style="color: ' + color + ';" class="tooltip2"    data-tooltip=\'' + JSON.stringify(x) + '\'>' + data + '</span>';
                            }
                            return data + ' ' + dataout;
                        }
                    },
                    {
                        targets: [4, 5, 6, 7, 8],
                        render: function (data, type, row, meta) {
                            let a = Object.values(data).sort((a, b) => {
                                switch (sortby) {
                                    case 'tong':
                                        return (vf(b.bu_val) + vf(b.sd_val) + vf(b.unknown_val)) - (vf(a.bu_val) + vf(a.sd_val) + vf(a.unknown_val))
                                        break
                                    default:
                                        return b[sortby] - a[sortby]
                                }

                            })
                            count = 0;
                            var dataout = ''
                            if (type === 'display') {
                                a.forEach(s => {
                                    count++;
                                    var color = 'blue'
                                    color = count % 2 === 0 ? 'blue' : 'green';
                                    dataout += '<a href="timeline?symbols=' + encodeURIComponent(s.symbol) + '"  target="_blank" class="custom-link"> <span style="color: ' + color + ';" class="tooltip"    data-tooltip=\'' + JSON.stringify(s) + '\'>(' + s.symbol + ':' + s.pct + ')</span> </a>';
                                    // dataout += '<a href="timeline?symbols=' + encodeURIComponent(s.symbol) + '"  target="_blank" class="custom-link"> <span style="color: ' + color + ';" class="tooltip"    data-tooltipster=\'' + JSON.stringify(s) + '\'>(' + s.symbol + ':' + s.pct + ')</span> </a>';
                                    // dataout += '<a href="timeline?symbols=' + encodeURIComponent(s.symbol) + '"  target="_blank" class="custom-link"> <span style="color: ' + color + ';" class="tooltip"   data-tooltip="' + s.bu_val + '<br/>' + s.sd_val + '">(' + s.symbol + ':' + s.pct + ')</span> </a>';
                                    // dataout += '<a href="timeline?symbols=' + encodeURIComponent(s.symbol) + '"  target="_blank" class="custom-link"> <span style="color: ' + color + ';" data-html="true" class="tooltip"  title="' + s.bu_val + '<br/>' + s.sd_val + '">(' + s.symbol + ':' + s.pct + ')</span> </a>';
                                })

                            }
                            return dataout;
                        }
                    },
                ],
                columns: [
                    ...fields.map(e => { return { data: e, orderable: true } })
                ],
                rowCallback: function (row, data, index) {
                    // if ((data['pct'] < 0)) {
                    //     // $(row).css('background-color', 'red');                
                    //     $('td:eq(5)', row).css('background-color', 'red');
                    // }
                    // else if ((data['pct'] > 0)) {
                    //     // $(row).css('background-color', 'green');
                    //     $('td:eq(5)', row).css('background-color', 'limegreen');
                    // } else {
                    //     // $(row).css('background-color', 'yellow');
                    //     $('td:eq(5)', row).css('background-color', 'yellow');
                    // }
                },
                order: [[2, 'desc']],
                processing: true,
                ordering: true,
                scroller: true,
                // scrollY: 200,
                searching: true,
                // serverSide: true,
                lengthMenu: [30, 50, 100, 200, 500, 2000],
                dom: 'lBfrtip',
                buttons: [
                    'copy',
                    'excel', 'pdf',
                    'colvis'
                ]

            }
        );


        async function updateChart(combineChart, data) {
            combineChart.data.labels = data.data.map(e => e.time)
            combineChart.data.datasets[0].data = data.data.map(e => e.price)
            combineChart.data.datasets[1].data = data.data.map(e => {
                let t = 0;
                [e.bu_val, e.sd_val, e.unknown_val].forEach(ee => {
                    if (ee) t += ee;
                })
                return t;
            })
            combineChart.data.datasets[2].data = data.data.map(e => e.bu_val)
            combineChart.data.datasets[3].data = data.data.map(e => e.sd_val)
            combineChart.data.datasets[4].data = data.data.map(e => e.bid_val)
            combineChart.data.datasets[5].data = data.data.map(e => e.ask_val)
            combineChart.update();
        }

        var sectorCodeList;
        $.ajax({
            url: `/api/getsectorcodelist`,
            method: 'GET',
            success: function (response) {
                sectorCodeList = response;
            },
            error: function (error) {
                console.error('Error fetching updated data:', error);
            }
        });


        let timeout = 0;
        let lastMd5 = ''
        let lastAJAX = 0

        function updateDataTable() {
            if (Date.now() - lastAJAX <= timeout) {
                return;
            }
            $.ajax({
                url: `/api/getsymbolsaccum`,
                method: 'GET',
                success: function (response) {

                    if (response.length == 0) {
                        return;
                    }
                    let mapSymbol = {}
                    response.forEach(e => {
                        mapSymbol[e.symbol] = e
                    })
                    let dataAll = [];
                    let statsAll = []
                    // console.table(response)

                    let total = (d) => {
                        return vf(d['bu_val']) + vf(d['sd_val']) + vf(d['unknown_val'])
                    }

                    if (sectorCodeList) {
                        let sectorStat = {}
                        let accumField = ["pct", "unknown_vol", "unknown_val", "bu_vol", "bu_val", "sd_vol", "sd_val", "bid_vol", "bid_val", "ask_vol", "ask_val", "busd_vol", "busd_val"]
                        let marketStat = { tran: 0, tang: 0, thamchieu: 0, giam: 0, san: 0, UP: { count: 0, bigCount: 0 }, DOWN: { count: 0, bigCount: 0 }, REF: { count: 0, bigCount: 0 }, CEILING: { count: 0, bigCount: 0 }, FLOOR: { count: 0, bigCount: 0 } }
                        accumField.forEach(f => {
                            marketStat.UP[f] = 0
                            marketStat.DOWN[f] = 0
                            marketStat.REF[f] = 0
                            marketStat.CEILING[f] = 0
                            marketStat.FLOOR[f] = 0
                        })
                        sectorCodeList.map(e => {
                            let stat = { tran: 0, tang: 0, thamchieu: 0, giam: 0, san: 0 }
                            let statSymbol = { tran: {}, tang: {}, thamchieu: {}, giam: {}, san: {} }
                            let accum = { UP: {}, DOWN: {}, REF: {}, CEILING: {}, FLOOR: {} }
                            accumField.forEach(f => {
                                accum.UP[f] = 0
                                accum.DOWN[f] = 0
                                accum.REF[f] = 0
                                accum.CEILING[f] = 0
                                accum.FLOOR[f] = 0
                            })
                            var lastTime = '';
                            var lastT = 0


                            e.codeList.forEach(
                                s => {
                                    let symbolData = mapSymbol[s];
                                    if (symbolData) {
                                        if (+symbolData.T > lastT) {
                                            lastT = +symbolData.T
                                            lastTime = symbolData.time
                                        }
                                        if (symbolData.pct == 0) {
                                            stat.thamchieu += 1
                                            marketStat.REF.count += 1;
                                            if (total(symbolData) >= valMin) {
                                                marketStat.REF.bigCount += 1;
                                                if (!marketStat.REF.bigPct) marketStat.REF.bigPct = 0
                                                marketStat.REF.bigPct += symbolData['pct']
                                            }
                                            accumField.forEach(f => {
                                                marketStat.REF[f] += vf(symbolData[f])
                                                accum.REF[f] += vf(symbolData[f])
                                            })

                                            statSymbol.thamchieu[s] = symbolData
                                        }
                                        if (symbolData.pct > 0) {
                                            if (symbolData.ceiling == symbolData.price) {
                                                stat.tran += 1
                                                marketStat.tran += 1
                                                statSymbol.tran[s] = symbolData
                                                marketStat.CEILING.count += 1;
                                                if (total(symbolData) >= valMin) {
                                                    marketStat.CEILING.bigCount += 1;
                                                    if (!marketStat.CEILING.bigPct) marketStat.CEILING.bigPct = 0
                                                    marketStat.CEILING.bigPct += symbolData['pct']
                                                }
                                                accumField.forEach(f => {
                                                    marketStat.CEILING[f] += vf(symbolData[f])
                                                    accum.CEILING[f] += vf(symbolData[f])
                                                })
                                            }
                                            else {
                                                stat.tang += 1
                                                marketStat.tang += 1
                                                statSymbol.tang[s] = symbolData
                                                marketStat.UP.count += 1;
                                                if (total(symbolData) >= valMin) {
                                                    marketStat.UP.bigCount += 1;
                                                    if (!marketStat.UP.bigPct) marketStat.UP.bigPct = 0
                                                    marketStat.UP.bigPct += symbolData['pct']
                                                }
                                                accumField.forEach(f => {
                                                    marketStat.UP[f] += vf(symbolData[f])
                                                    accum.UP[f] += vf(symbolData[f])
                                                })
                                            }



                                        }
                                        if (symbolData.pct < 0) {

                                            if (symbolData.floor == symbolData.price) {
                                                stat.san += 1
                                                marketStat.san += 1
                                                statSymbol.san[s] = symbolData
                                                marketStat.FLOOR.count += 1;
                                                if (total(symbolData) >= valMin) {
                                                    marketStat.FLOOR.bigCount += 1;
                                                    if (!marketStat.FLOOR.bigPct) marketStat.FLOOR.bigPct = 0
                                                    marketStat.FLOOR.bigPct += symbolData['pct']
                                                }
                                                accumField.forEach(f => {
                                                    marketStat.FLOOR[f] += vf(symbolData[f])
                                                    accum.FLOOR[f] += vf(symbolData[f])
                                                })
                                            }
                                            else {
                                                stat.giam += 1
                                                marketStat.giam += 1
                                                statSymbol.giam[s] = symbolData
                                                marketStat.DOWN.count += 1;
                                                if (total(symbolData) >= valMin) {
                                                    marketStat.DOWN.bigCount += 1;
                                                    if (!marketStat.DOWN.bigPct) marketStat.DOWN.bigPct = 0
                                                    marketStat.DOWN.bigPct += symbolData['pct']
                                                }
                                                accumField.forEach(f => {
                                                    marketStat.DOWN[f] += vf(symbolData[f])
                                                    accum.DOWN[f] += vf(symbolData[f])
                                                })
                                            }


                                        }
                                    }

                                }
                            )

                            let t = Object.values(stat).reduce((a, b) => { return a + b }, 0)
                            if (t > 0) {
                                Object.keys(stat).forEach(k => {
                                    if (percent)
                                        stat[k] = Math.floor(stat[k] / t * 1000) / 10
                                })
                            }
                            // console.log(e.vietnameseName)
                            // console.table(stat)
                            sectorStat[e.vietnameseName] = { stat: stat, accum: accum, statSymbol: statSymbol, time: lastTime, T: lastT }

                        })

                        let labels = Object.keys(sectorStat);
                        let tran = Object.values(sectorStat).map(e => e.stat.tran)
                        let tang = Object.values(sectorStat).map(e => e.stat.tang)
                        let thamchieu = Object.values(sectorStat).map(e => e.stat.thamchieu)
                        let giam = Object.values(sectorStat).map(e => e.stat.giam)
                        let san = Object.values(sectorStat).map(e => e.stat.san)

                        let F = ["CEILING", "UP", "REF", "DOWN", "FLOOR"]
                        let sum = {}
                        F.forEach(f => {
                            sum[f] = Object.values(sectorStat).map(e => e.accum[f].bu_val + e.accum[f].sd_val + e.accum[f].unknown_val)
                        })

                        labelValue = Object.values(sectorStat).map(e => {
                            return F.map(f => {
                                return e.accum[f].bu_val + e.accum[f].sd_val + e.accum[f].unknown_val
                            }).reduce((a, b) => { return a + b }, 0)
                        })

                        var totalVal = labelValue.reduce((a, b) => a + b, 0)
                        labelValue2 = labelValue.map(e => Math.floor(e / totalVal * 10000) / 100)

                        combineChart.data.labels = labels
                        combineChart.data.datasets[0].data = tran
                        combineChart.data.datasets[1].data = tang
                        combineChart.data.datasets[2].data = thamchieu
                        combineChart.data.datasets[3].data = giam
                        combineChart.data.datasets[4].data = san
                        combineChart.update();


                        combineChartVal.data.labels = labels
                        combineChartVal.data.datasets[0].data = sum.CEILING
                        combineChartVal.data.datasets[1].data = sum.UP
                        combineChartVal.data.datasets[2].data = sum.REF
                        combineChartVal.data.datasets[3].data = sum.DOWN
                        combineChartVal.data.datasets[4].data = sum.FLOOR
                        combineChartVal.options.plugins.datalabels;
                        console.log(sum.FLOOR)
                        combineChartVal.update();
                        var sectorTable = {}
                        Object.keys(sectorStat).forEach(sector => {
                            var sd = sectorStat[sector]
                            var all = {}
                            var allBig = {}
                            Object.keys(sd.statSymbol).forEach(e => {
                                var d = sd.statSymbol[e];
                                Object.keys(d).forEach(s => {
                                    all[s] = d[s]
                                    if (total(d[s]) >= valMin) {
                                        allBig[s] = d[s]
                                    }
                                })
                            })
                            var a = Object.values(all);
                            var all1 = '';
                            if (a.length > 0)
                                all1 = Math.floor(a.reduce((x, y) => vf(y.pct) + x, 0) / a.length * 100) / 100
                            a = Object.values(allBig);
                            var allBig1 = ''
                            if (a.length > 0)
                                allBig1 = Math.floor(Object.values(allBig).reduce((x, y) => vf(y.pct) + x, 0) / a.length * 100) / 100
                            sectorTable[sector] = { sector: sector, time: sd.time, T: sd.T, all: all1, allO: all, allBig: allBig1, allBigO: allBig, ...sd.statSymbol }
                        })

                        // console.table(sectorTable)

                        var table = $('#myTable').DataTable();
                        table.clear();
                        table.rows.add(Object.values(sectorTable)).draw()
                        // $('.tooltip').tooltipster();
                        // $('#mytable').DataTable();

                        // // Initialize Tooltipster for all elements with the 'tooltip' class
                        $('.tooltip').tooltipster({
                            // functionBefore: function (instance,helper) {
                            //     // Retrieve the tooltip content from the data-tooltip attribute
                            //     // callback($(this).data('tooltip'));
                            //     // console.table(instance)
                            //     console.log( $(helper.origin))
                            // }
                            functionInit: function (instance, helper) {
                                var content = $(helper.origin).data('tooltip')
                                // console.log(content.symbol)
                                // data=JSON.parse(content)
                                instance.content(() => {
                                    return generateDynamicContent(content)
                                });
                            },
                            timer: 15000,
                            theme: 'my-custom-theme',
                            side: 'top'
                        });

                        $('.tooltip2').tooltipster({
                            functionInit: function (instance, helper) {
                                var content = $(helper.origin).data('tooltip')
                                instance.content(() => {
                                    return generateDynamicContent2(content)
                                });
                            },
                            timer: 15000,
                            theme: 'my-custom-theme',
                            side: 'top'
                        });
                        // // Initialize Tooltipster for all elements with the 'tooltip' class

                        // function generateDynamicContent() {
                        //     // You can generate dynamic content based on your logic
                        //     return '<p>This is dynamic HTML content.</p>' +
                        //         '<ul>' +
                        //         '<li>Item 1</li>' +
                        //         '<li>Item 2</li>' +
                        //         '<li>Item 3</li>' +
                        //         '</ul>';
                        // }

                        var fm = (v) => {
                            if (Number.isInteger(v)) {
                                return numeral(v).format('0,0');
                            } else {
                                return numeral(v).format('0,0.00');
                            }
                        }
                        function generateDynamicContent(data) {
                            // You can generate dynamic content based on your logic
                            return '<div class="tooltipContainer"><h2 style="font-weight: bold; color: red;">Thông tin mã.</h2>' +
                                '<ul>' +
                                '<li>Tên mã <span style="font-weight: bold; color: red;">' + data.symbol + '</span></li>' +
                                '<li>Giá ' + data.price
                                + '<span style="font-weight: bold; color: magenta;"> ' + data.ceiling + '</span>'
                                + '<span style="font-weight: bold; color: cyan;"> ' + data.floor + '</span>'
                                + '<span style="font-weight: bold; color: GoldenRod;"> ' + data.priceref + '</span>'
                                + '</li>' +
                                '<li>Thay đổi ' + data.change + '</li>' +
                                '<li>Tỉ lệ ' + data.pct + '</li>' +
                                '<li>Val Mua ' + fm(vf(data.bu_val)) + '</li>' +
                                '<li>Val Bán ' + fm(vf(data.sd_val)) + '</li>' +
                                '<li>Val KXĐ ' + fm(vf(data.unknown_val)) + '</li>' +
                                '<li>Val Mua-Bán ' + fm(vf(data.busd_val)) + '</li>' +
                                '<li>Vol Mua ' + fm(vf(data.bu_vol)) + '</li>' +
                                '<li>Vol Bán ' + fm(vf(data.sd_vol)) + '</li>' +
                                '<li>Vol KXĐ ' + fm(vf(data.unknown_vol)) + '</li>' +
                                '<li>Vol Mua-Bán ' + fm(vf(data.busd_vol)) + '</li>' +
                                '<li>Đặt Mua ' + fm(vf(data.bid_val)) + '</li>' +
                                '<li>Đặt Bán ' + fm(vf(data.ask_val)) + '</li>' +
                                '<li>Vol Đặt Mua ' + fm(vf(data.bid_vol)) + '</li>' +
                                '<li>Vol Đặt Bán ' + fm(vf(data.ask_vol)) + '</li>' +
                                '</ul>' +
                                '<img src="logo.5ecddcbe.svg" alt="Your Image"> </div>';
                            ;
                        }

                        function generateDynamicContent2(data) {
                            // You can generate dynamic content based on your logic
                            var out = '<div class="tooltipContainer"><h2 style="font-weight: bold; color: red;">Thông tin mã.</h2>' +
                                '<ul>'

                            data.forEach(s => {
                                var color = 'gold'
                                if (s.pct > 0) {
                                    if (s.price === s.ceiling) {
                                        color = "magenta"
                                    } else {
                                        color = "green"
                                    }
                                }
                                if (s.pct < 0) {
                                    if (s.price === s.floor) {
                                        color = "cyan"
                                    } else {
                                        color = "red"
                                    }
                                }
                                var format = ''
                                if (total(s) < 1000000000) format = '0,0.000'
                                else format = '0,0.00'
                                out += '<li> Mã ' + s.symbol
                                    + '<span style="font-weight: bold; color: ' + color + ';">: ' + s.pct + ' ' + numeral(s.price).format('0,0') + ' ' + numeral(total(s) / 1000000000).format(format) + '(Tỉ)</span>'
                                    + '</li>'

                            })
                            out += '</ul>' +
                                '<img src="logo.5ecddcbe.svg" alt="Your Image"> </div>';
                            return out;
                        }

                        // $('.tooltip').tooltipster({
                        //     functionInit: function (instance, helper) {

                        //         var $origin = $(helper.origin),
                        //             dataOptions = $origin.attr('data-tooltipster');
                        //             console.log(dataOptions)
                        //             data = JSON.parse(dataOptions)
                        //         instance.content(()=>{
                        //             return generateDynamicContent(data)
                        //         });
                        //         // console.log('DataOption',dataOptions)
                        //         // if (dataOptions) {

                        //         //     dataOptions = JSON.parse(dataOptions);
                        //         //     $.each(dataOptions, function (name, option) {

                        //         //         instance.option(name, option);
                        //         //     });
                        //         // }
                        //     },
                        //     timer: 15000
                        // });

                        statsHead.innerHTML = ''
                        var theadRow = document.createElement('tr');
                        statsHead.appendChild(theadRow);

                        label1 = ['Thống kê', '', '', '', 'Tổng', 'Tổng', 'Tổng', 'Tổng', 'Tổng',]
                        sum = [, , , , marketStat.CEILING, marketStat.UP, marketStat.REF, marketStat.DOWN, marketStat.FLOOR]
                        for (var i = 0; i < label1.length; i++) {
                            var th = document.createElement('th');
                            if (i <= 3) {
                                th.textContent = label1[i];
                            } else {
                                th.innerHTML = '<div>' + label1[i] + '</div>\n<div>' + numeral(sum[i].count).format('0,0') + '</div>'
                                    + '<div>Avg: ' + numeral(sum[i].pct / sum[i].count).format('0,0.00') + '</div>'
                                    + '<div>BigCount: ' + numeral(sum[i].bigCount).format('0,0') + '</div>'
                                    + '<div>AvgBig: ' + numeral(sum[i].bigPct / sum[i].bigCount).format('0,0.00') + '</div>'
                                // + '<div>' + 'BigCount' + '</div>'

                            }
                            theadRow.appendChild(th);

                        }

                    }





                    lastAJAX = Date.now()
                    // if (lastMd5 == response.md5) {
                    //     timeout += 1000
                    //     if (timeout >= 10000) {
                    //         timeout = 10000;
                    //         console.log('Timeout ', timeout, 'md5', response.md5)
                    //     }
                    // } else {
                    //     timeout = 0;
                    // }
                    // // console.table(response)
                    // lastMd5 = response.md5
                },
                error: function (error) {
                    console.error('Error fetching updated data:', error);
                }
            });
        }
        // updateDataTable()
        // Update DataTable every 5 seconds (adjust as needed)
        setInterval(updateDataTable, interval * 1000);

        $(document).ready(function () {
            // Event listener for mouseover on cells     

            $('#mytable').DataTable();

            // Initialize Tooltipster for all elements with the 'tooltip' class
            console.log('Active tooltipse1')

            $('.tooltip').tooltipster();
            // $('.tooltip').tooltipster({
            //     content: function (callback) {
            //         // Retrieve the tooltip content from the data-tooltip attribute
            //         console.log('Active tooltipse')
            //         callback($(this).data('tooltip'));
            //     }
            // });
        });


        document.addEventListener('keydown', function (event) {
            // Check if the pressed key is the one you want (e.g., 'Enter' key with keyCode 13)
            if (event.key.toUpperCase() === 'R') {
                combineChart.resetZoom();
                combineChartVal.resetZoom();
                combineChart.update();
                combineChartVal.update();
            }
        });

    </script>
</body>

</html>